<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Optical tracking of vinyl records | Étienne André&#39;s blog</title>

    <link rel="stylesheet" href="/css/main.css">


      <script src="/js/main.js"></script>



<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
    MathJax = {
        tex: {
            displayMath: [['\\[', '\\]'], ['$$', '$$']],  
            inlineMath: [['\\(', '\\)'], ['$', '$']],      
            tags: 'all'
        }
    };
</script>

</head>
<body>
  <header>
    <h1>Étienne André&#39;s blog</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/posts/">Posts</a>
    </li>
    <li>
      <a href="/tags/">Tags</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>Optical tracking of vinyl records</h1>

  
  
  <time datetime="2024-09-26T14:48:48&#43;02:00">September 26, 2024</time>

  <p>We implemented an optical tracking method to measure the angular velocity of a vinyl record during playback, enabling the extraction of the time-warping ground truth from a filmed DJ performance. The method can be especially useful given the vast amount of videos of DJ performances online. By tracking a reference picture of a vinyl record to each frame of a video of a DJ turntable, the record&rsquo;s rotation speed can be estimated.</p>
$$ 2+2 = 4 \frac{A}{B} $$<h2 id="tracking">Tracking</h2>
<p>The tracking is based on the scale-invariant feature transform (SIFT) algorithm @loweDistinctiveImageFeatures2004. The algorithm extracts keypoints from a reference image of the vinyl&rsquo;s label (@fig:vinyl-ref) and from each frame of a video of the vinyl being played. By matching these keypoints, a homography matrix is computed for each frame. This matrix represents the geometric transformation between the reference and the current frame, capturing the rotation, translation, and scale changes (@fig:vinyl-track). The sequence of homography matrices obtained across the frames is stored for further analysis.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> itertools <span style="color:#f92672">import</span> count
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> cv2 <span style="color:#66d9ef">as</span> cv
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#66d9ef">as</span> plt
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> tqdm <span style="color:#f92672">import</span> tqdm
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pickle
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>DRAW <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">resize_to_width</span>(mat, w):
</span></span><span style="display:flex;"><span>    h <span style="color:#f92672">=</span> int(mat<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> w <span style="color:#f92672">/</span> mat<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> cv<span style="color:#f92672">.</span>resize(mat, (w, h), interpolation<span style="color:#f92672">=</span>cv<span style="color:#f92672">.</span>INTER_AREA)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sift <span style="color:#f92672">=</span> cv<span style="color:#f92672">.</span>SIFT_create()
</span></span><span style="display:flex;"><span>img1 <span style="color:#f92672">=</span> cv<span style="color:#f92672">.</span>imread(<span style="color:#e6db74">&#34;darktable_exported/P3160003.jpg&#34;</span>, cv<span style="color:#f92672">.</span>IMREAD_GRAYSCALE)
</span></span><span style="display:flex;"><span>img1 <span style="color:#f92672">=</span> resize_to_width(img1, <span style="color:#ae81ff">500</span>)
</span></span><span style="display:flex;"><span>kp1, des1 <span style="color:#f92672">=</span> sift<span style="color:#f92672">.</span>detectAndCompute(img1, <span style="color:#66d9ef">None</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>matrices <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cap <span style="color:#f92672">=</span> cv<span style="color:#f92672">.</span>VideoCapture(<span style="color:#e6db74">&#34;P3160002.MOV&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># matcher = cv.FlannBasedMatcher(</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#     {&#34;algorithm&#34;: 1, &#34;trees&#34;: 5},</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#     {&#34;checks&#34;: 50},</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># )</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>matcher <span style="color:#f92672">=</span> cv<span style="color:#f92672">.</span>BFMatcher()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> tqdm(count(<span style="color:#ae81ff">0</span>), total<span style="color:#f92672">=</span><span style="color:#ae81ff">56</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">60</span>):
</span></span><span style="display:flex;"><span>    ret, img2 <span style="color:#f92672">=</span> cap<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ret:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>    img2 <span style="color:#f92672">=</span> cv<span style="color:#f92672">.</span>cvtColor(img2, cv<span style="color:#f92672">.</span>COLOR_BGR2GRAY)
</span></span><span style="display:flex;"><span>    img2 <span style="color:#f92672">=</span> resize_to_width(img2, <span style="color:#ae81ff">500</span>)
</span></span><span style="display:flex;"><span>    kp2, des2 <span style="color:#f92672">=</span> sift<span style="color:#f92672">.</span>detectAndCompute(img2, <span style="color:#66d9ef">None</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    matches <span style="color:#f92672">=</span> matcher<span style="color:#f92672">.</span>knnMatch(des1, des2, k<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    good <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> m, n <span style="color:#f92672">in</span> matches:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> m<span style="color:#f92672">.</span>distance <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.7</span> <span style="color:#f92672">*</span> n<span style="color:#f92672">.</span>distance:
</span></span><span style="display:flex;"><span>            good<span style="color:#f92672">.</span>append(m)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(good) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">10</span>:
</span></span><span style="display:flex;"><span>        src_pts <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>float32([kp1[m<span style="color:#f92672">.</span>queryIdx]<span style="color:#f92672">.</span>pt <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> good])<span style="color:#f92672">.</span>reshape(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>        dst_pts <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>float32([kp2[m<span style="color:#f92672">.</span>trainIdx]<span style="color:#f92672">.</span>pt <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> good])<span style="color:#f92672">.</span>reshape(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        M, mask <span style="color:#f92672">=</span> cv<span style="color:#f92672">.</span>findHomography(src_pts, dst_pts, cv<span style="color:#f92672">.</span>RANSAC, <span style="color:#ae81ff">5.0</span>)
</span></span><span style="display:flex;"><span>        matchesMask <span style="color:#f92672">=</span> mask<span style="color:#f92672">.</span>ravel()<span style="color:#f92672">.</span>tolist()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        h, w <span style="color:#f92672">=</span> img1<span style="color:#f92672">.</span>shape
</span></span><span style="display:flex;"><span>        pts <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>float32([[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, h <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], [w <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, h <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], [w <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]])<span style="color:#f92672">.</span>reshape(
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        matrices<span style="color:#f92672">.</span>append(M)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;matrices.pickle&#34;</span>, <span style="color:#e6db74">&#34;wb&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>            pickle<span style="color:#f92672">.</span>dump(matrices, f)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> DRAW:
</span></span><span style="display:flex;"><span>            dst <span style="color:#f92672">=</span> cv<span style="color:#f92672">.</span>perspectiveTransform(pts, M)
</span></span><span style="display:flex;"><span>            img2 <span style="color:#f92672">=</span> cv<span style="color:#f92672">.</span>polylines(img2, [np<span style="color:#f92672">.</span>int32(dst)], <span style="color:#66d9ef">True</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">3</span>, cv<span style="color:#f92672">.</span>LINE_AA)
</span></span><span style="display:flex;"><span>            cv<span style="color:#f92672">.</span>imwrite(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;out-</span><span style="color:#e6db74">{</span>i<span style="color:#e6db74">:</span><span style="color:#e6db74">05d</span><span style="color:#e6db74">}</span><span style="color:#e6db74">.jpg&#34;</span>, img2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Not enough matches are found - </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">/</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(len(good), <span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>        matchesMask <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> DRAW:
</span></span><span style="display:flex;"><span>            cv<span style="color:#f92672">.</span>imwrite(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;out-</span><span style="color:#e6db74">{</span>i<span style="color:#e6db74">:</span><span style="color:#e6db74">05d</span><span style="color:#e6db74">}</span><span style="color:#e6db74">.jpg&#34;</span>, img2)
</span></span><span style="display:flex;"><span>        matrices<span style="color:#f92672">.</span>append(<span style="color:#66d9ef">None</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;matrices.pickle&#34;</span>, <span style="color:#e6db74">&#34;wb&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>            pickle<span style="color:#f92672">.</span>dump(matrices, f)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cap<span style="color:#f92672">.</span>release()
</span></span></code></pre></div><figure><img src="/posts/dj-transcription/vinyl-optical-tracking-dj/vinyl-ref.jpg"><figcaption>
      <h4>Reference image of the vinyl label.</h4>
    </figcaption>
</figure>

<video controls preload="auto" width="100%"  playsinline class="html-video">
    <source src="/posts/dj-transcription/vinyl-optical-tracking-dj/out.mp4" type="video/mp4">
  <span>Your browser doesn't support embedded videos, but don't worry, you can <a href="/posts/dj-transcription/vinyl-optical-tracking-dj/out.mp4">download it</a> and watch it with your favorite video player!</span>
</video>
<!-- raw HTML omitted -->
<h2 id="rotation-computation">Rotation computation</h2>
<p>The stored homography matrices are then decomposed to extract the rotation angles of the vinyl record using the singular value decomposition method from #cite(<!-- raw HTML omitted -->, form: &ldquo;prose&rdquo;). The rotation on the $z$ axis corresponds to the rotation of the vinyl record. The rotation angle sequence is unwrapped then derived to obtain the rotation speed. Then, with knowledge of the nominal speed of the record (e.g. 33 or 45 rpm), the time-warping function can be calculated. Example results are illustrated in @fig:vinyl-results.</p>
<figure><img src="/posts/dj-transcription/vinyl-optical-tracking-dj/rotato.svg"><figcaption>
      <h4>Computed angle and rotation speed of the vinyl. In the experiment, the record was played at 33 rpm for the first 30 seconds, then was &#34;scratched&#34; by hand for the remaining of the experiment.</h4>
    </figcaption>
</figure>

<p>The accuracy of the extracted rotational speed is directly dependent on the temporal resolution of the video (usually 30 or 60 images per second), which limits the granularity of the measurements. Additionally, the method is susceptible to noise introduced by the tracking process, which can affect the precision of the rotation and speed calculations.</p>
<p>Similar object tracking techniques could be used to extract ground truth data from any visible physical control of the DJ equipment.</p>

  


  </main>
  <footer>
    <p>Copyright 2024. All rights reserved.</p>

  </footer>
</body>
</html>
